from copy import deepcopy

FINAL_CANONICAL_CONFIGURATION = [
    [1, 2, 3, 4],
    [5, 6, 7, 8],
    [9, 10, 11, 12],
    [13, 14, 15, 0]
]


class ShortSequenceSolver15:
    initial_state = None
    explored_set = None
    is_solvable = None
    moves = None
    row = None
    column = None

    def __init__(self, filename):
        """
        Parameterized constructor reads input file and checks for solvability.
        :param filename:
        """

        self.read_check_input_file(filename)
        self.explored_set = []
        self.moves = []

    def read_check_input_file(self, filename):
        """
        Reads the puzzle to a 2-D matrix and checks if puzzle is solvable
        :param filename:
        :return:
        """

        with open(filename, "r") as file_handle:
            self.initial_state = [
                [
                    int(j) for j in i
                ] for i in [
                    line.split() for line in file_handle
                ]
            ]

        self.is_solvable = self.is_puzzle_solvable(self.initial_state)

    @staticmethod
    def manhattan_distance(successor_state):
        """
        Heuristic ==> Manhattan distance
        https://stackoverflow.com/questions/12526792/manhattan-distance-in-a
        :param successor_state:
        :return:
        """

        manhattan_distance_sum = 0
        for row1 in range(4):
            for column1 in range(4):
                value = successor_state[row1][column1]
                if value != 0:
                    target_x = (value - 1) // 4
                    target_y = (value - 1) % 4
                    diff_x = row1 - target_x
                    diff_y = column1 - target_y
                    manhattan_distance_sum += abs(diff_x) + abs(diff_y)

        return manhattan_distance_sum

    def successors(self, tiles):
        """
        Successor states generated by moving tiles by one, two
        or three positions to the top, bottom,
        left or right as appropriate
        :param tiles:
        :return:
        """

        successor_states = []
        moves = []
        for i in range(4):
            for j in range(4):
                if i == self.row and j == self.column:
                    # move up by one tile
                    if i > 0:
                        tiles[i][j], tiles[i - 1][j] = tiles[i - 1][j], tiles[i][j]
                        successor_states.append(deepcopy(tiles))
                        tiles[i][j], tiles[i - 1][j] = tiles[i - 1][j], tiles[i][j]
                        move = "U" + str(self.row + 1)  # sequence of moves string builder
                        moves.append(move)  # sequence of the move list
                    # move up by one tile

                    # move down by one tile
                    if i < 3:
                        tiles[i][j], tiles[i + 1][j] = tiles[i + 1][j], tiles[i][j]
                        successor_states.append(deepcopy(tiles))
                        tiles[i][j], tiles[i + 1][j] = tiles[i + 1][j], tiles[i][j]
                        move = "D" + str(self.row + 1)
                        moves.append(move)
                    # move down by one tile

                    # move left by one tile
                    if j > 0:
                        tiles[i][j], tiles[i][j - 1] = tiles[i][j - 1], tiles[i][j]
                        successor_states.append(deepcopy(tiles))
                        tiles[i][j], tiles[i][j - 1] = tiles[i][j - 1], tiles[i][j]
                        move = "L" + str(self.column + 1)
                        moves.append(move)
                    # move left by one tile

                    # move right by one tile
                    if j < 3:
                        tiles[i][j], tiles[i][j + 1] = tiles[i][j + 1], tiles[i][j]
                        successor_states.append(deepcopy(tiles))
                        tiles[i][j], tiles[i][j + 1] = tiles[i][j + 1], tiles[i][j]
                        move = "R" + str(self.column + 1)
                        moves.append(move)
                    # move right by one tile

        return [successor_states, moves]

    @staticmethod
    def is_goal(successor_state):
        """
        Checks whether current state is the goal state or not.
        :return:
        """

        for idx, row in enumerate(successor_state):
            for jdx, value in enumerate(row):
                if value != FINAL_CANONICAL_CONFIGURATION[idx][jdx]:
                    return False

        return True

    @staticmethod
    def get_inv_count(tile):
        """
        http://www.geeksforgeeks.org/check-instance-15-puzzle-solvable/
        A utility function to count inversions in given tile(1-D)
        :return:
        """
        inv_count = 0
        for i in range(15):
            for j in range(i + 1, 16):
                # count pairs(i, j) such that i appears before j, but i > j.
                if tile[j] and tile[i] and tile[i] > tile[j]:
                    inv_count += 1

        return inv_count

    @staticmethod
    def find_x_position(tile):
        """
        http://www.geeksforgeeks.org/check-instance-15-puzzle-solvable/
        find Position of blank from bottom starting from the bottom-right corner of matrix
        :param tile:
        :return:
        """

        for i in range(3, -1, -1):
            for j in range(3, -1, -1):
                if tile[i][j] == 0:
                    return 4 - i

    def is_puzzle_solvable(self, tile):
        """
        http://www.geeksforgeeks.org/check-instance-15-puzzle-solvable/
        This function returns true if given instance of 15-puzzle is solvable.
        :param tile:
        :return:
        """

        # Count inversions in given puzzle
        tile_1d = [0 for _ in range(16)]
        for i in range(4):
            for j in range(4):
                tile_1d[4 * i + j] = tile[i][j]

        inv_count = self.get_inv_count(tile_1d)

        # If grid is odd, return true if inversion count is even.
        if 4 & 1:
            return not inv_count & 1

        pos = ShortSequenceSolver15.find_x_position(tile)
        if pos & 1:
            return not inv_count & 1

        return inv_count & 1

    def solve(self):
        """
        Invokes the A-star algorithm to solve the 15-puzzle if it is solvable.
        :return:
        """

        if self.is_solvable:
            return self.solve_a_star(
                self.initial_state,
                self.explored_set,
                self.moves,
                g_cost=1
            )

    def solve_a_star(self, state, explored_state, moves, g_cost):
        """
        A-star search finds the best promising state after each step
        based on min 'f'(g + h) value till the goal state is reached.
        :param state:
        :param explored_state:
        :param moves:
        :param g_cost:
        :return: Returns a string that represents the output of the program.
        """

        if ShortSequenceSolver15.is_goal(state):
            return 0
        # find row and column number of the 'blank' tile.
        self.row, self.column = [
            (index, row.index(0)) for index, row in enumerate(state) if 0 in row
        ][0]

        tmp = []
        successors = self.successors(state)[0]
        successors_moves = self.successors(state)[1]

        for cnt, condition in enumerate(successors):
            if ShortSequenceSolver15.is_goal(condition):
                explored_state.append(condition)
                moves.append(successors_moves[cnt])
                return 0

            h_cost = ShortSequenceSolver15.manhattan_distance(condition)
            tmp.append((condition, successors_moves[cnt], g_cost + h_cost))

        # https://stackoverflow.com/questions/10695139/sort-a-list-of-tuples-by-2nd-item-integer-value
        # next_promising_state is chosen based on min f_cost = g_cost + h_cost
        sorted_tmp = sorted(tmp, key=lambda x: x[2])
        next_promising_state = sorted_tmp[0][0]
        explored_state.append(next_promising_state)
        moves.append(sorted_tmp[0][1])
        # https://algorithmsinsight.wordpress.com/graph-theory-2/a-star-in-general/implementing-a-star-to-solve-n-puzzle/
        g_cost += 1

        # recursively iterate through promising states to reach the goal state
        self.solve_a_star(next_promising_state, explored_state, moves, g_cost)

    def __str__(self):
        if self.is_solvable:
            if self.moves:
                output_str = ""
                output_str += "\n".join(str(row) for row in [self.initial_state] + self.explored_set)
                output_str += "\n\nSEQUENCE OF MOVES:\n" + " ".join(self.moves)
                return output_str

            return "INPUT PUZZLE IS IN SOLVED STATE."

        return "PUZZLE NOT SOLVABLE"


def main():
    filename = "puzzle_15.txt"
    solver = ShortSequenceSolver15(filename)
    solver.solve()
    print(str(solver))


if __name__ == "__main__":
    main()
