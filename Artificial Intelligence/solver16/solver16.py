from copy import deepcopy

FINAL_CANONICAL_CONFIGURATION = [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 0]]


class ShortSequenceSolver16:
    initial_state = None
    explored_set = None
    is_solvable = None
    moves = None
    row = None
    column = None

    def __init__(self, filename):
        """
        Parameterized constructor reads input file and checks for solvability.
        :param filename:
        """

        self.read_check_input_file(filename)
        self.explored_set = []
        self.moves = []

    def read_check_input_file(self, filename):
        """
        Reads the puzzle to a 2-D matrix and checks if puzzle is solvable
        :param filename:
        :return:
        """

        with open(filename, "r") as file_handle:
            self.initial_state = [
                [int(j) for j in i] for i in [line.split() for line in file_handle]
            ]

        self.is_solvable = ShortSequenceSolver16.is_puzzle_solvable(self.initial_state)

    @staticmethod
    def manhattan_distance(successor_state):
        """
        Heuristic ==> Manhattan distance
        https://stackoverflow.com/questions/12526792/manhattan-distance-in-a
        :param successor_state:
        :return:
        """

        manhattan_distance_sum = 0
        for row1 in range(4):
            for column1 in range(4):
                value = successor_state[row1][column1]
                if value != 0:
                    target_x = (value - 1) // 4
                    target_y = (value - 1) % 4
                    diff_x = row1 - target_x
                    diff_y = column1 - target_y
                    manhattan_distance_sum += (
                        abs(diff_x) + abs(diff_y)
                    ) / 3.0  # Divide by 3 for admissible heuristic

        return manhattan_distance_sum

    # Successor states generated by moving tiles by one,
    # two or three positions to the top, bottom, left or right as appropriate
    def successors(self, tiles):
        successor_states = []
        moves = []
        for i in range(4):
            for j in range(4):
                if i == self.row and j == self.column:
                    tiles_copy = deepcopy(tiles)  # Make a deep copy of the tile for restored state.
                    # move up
                    r_copy = self.row
                    while r_copy > 0:
                        if r_copy == 1:
                            # move up by one tile
                            tiles = deepcopy(tiles_copy)
                            tiles[i][j], tiles[i - 1][j] = tiles[i - 1][j], tiles[i][j]
                            successor_states.append(tiles)
                            move = (
                                "D" + str(r_copy) + str(self.row + 1)
                            )  # sequence of moves string builder
                            moves.append(move)  # sequence of the move list
                            # move up by one tile
                        elif r_copy == 2:
                            # move up by two tiles
                            tiles = deepcopy(tiles_copy)
                            tiles[i][j], tiles[i - 1][j] = tiles[i - 1][j], tiles[i][j]
                            tiles[i - 1][j], tiles[i - 2][j] = tiles[i - 2][j], tiles[i - 1][j]
                            successor_states.append(tiles)
                            move = "D" + str(r_copy) + str(self.row + 1)
                            moves.append(move)
                            # move up by two tiles
                        elif r_copy == 3:
                            # move up by three tiles
                            tiles = deepcopy(tiles_copy)
                            tiles[i][j], tiles[i - 1][j] = tiles[i - 1][j], tiles[i][j]
                            tiles[i - 1][j], tiles[i - 2][j] = tiles[i - 2][j], tiles[i - 1][j]
                            tiles[i - 2][j], tiles[i - 3][j] = tiles[i - 3][j], tiles[i - 2][j]
                            successor_states.append(tiles)
                            move = "D" + str(r_copy) + str(self.row + 1)
                            moves.append(move)
                            # move up by three tiles
                        r_copy -= 1

                    # move down
                    r_copy = 3 - self.row
                    while r_copy > 0:
                        if r_copy == 1:
                            # move down by one tile
                            tiles = deepcopy(tiles_copy)
                            tiles[i][j], tiles[i + 1][j] = tiles[i + 1][j], tiles[i][j]
                            successor_states.append(tiles)
                            move = "U" + str(r_copy) + str(self.row + 1)
                            moves.append(move)
                            # move down by one tile
                        elif r_copy == 2:
                            # move down by two tiles
                            tiles = deepcopy(tiles_copy)
                            tiles[i][j], tiles[i + 1][j] = tiles[i + 1][j], tiles[i][j]
                            tiles[i + 1][j], tiles[i + 2][j] = tiles[i + 2][j], tiles[i + 1][j]
                            successor_states.append(tiles)
                            move = "U" + str(r_copy) + str(self.row + 1)
                            moves.append(move)
                            # move down by two tiles
                        elif r_copy == 3:
                            # move down by three tiles
                            tiles = deepcopy(tiles_copy)
                            tiles[i][j], tiles[i + 1][j] = tiles[i + 1][j], tiles[i][j]
                            tiles[i + 1][j], tiles[i + 2][j] = tiles[i + 2][j], tiles[i + 1][j]
                            tiles[i + 2][j], tiles[i + 3][j] = tiles[i + 3][j], tiles[i + 2][j]
                            successor_states.append(tiles)
                            move = "U" + str(r_copy) + str(self.row + 1)
                            moves.append(move)
                            # move down by three tiles
                        r_copy -= 1

                    # move left
                    c_copy = self.column
                    while c_copy > 0:
                        if c_copy == 1:
                            # move left by one tile
                            tiles = deepcopy(tiles_copy)
                            tiles[i][j], tiles[i][j - 1] = tiles[i][j - 1], tiles[i][j]
                            successor_states.append(tiles)
                            move = "R" + str(c_copy) + str(self.column + 1)
                            moves.append(move)
                            # move left by one tile
                        elif c_copy == 2:
                            # move left by two tiles
                            tiles = deepcopy(tiles_copy)
                            tiles[i][j], tiles[i][j - 1] = tiles[i][j - 1], tiles[i][j]
                            tiles[i][j - 1], tiles[i][j - 2] = tiles[i][j - 2], tiles[i][j - 1]
                            successor_states.append(tiles)
                            move = "R" + str(c_copy) + str(self.column + 1)
                            moves.append(move)
                            # move left by two tiles
                        elif c_copy == 3:
                            # move left by three tiles
                            tiles = deepcopy(tiles_copy)
                            tiles[i][j], tiles[i][j - 1] = tiles[i][j - 1], tiles[i][j]
                            tiles[i][j - 1], tiles[i][j - 2] = tiles[i][j - 2], tiles[i][j - 1]
                            tiles[i][j - 2], tiles[i][j - 3] = tiles[i][j - 3], tiles[i][j - 2]
                            successor_states.append(tiles)
                            move = "R" + str(c_copy) + str(self.column + 1)
                            moves.append(move)
                            # move left by three tiles
                        c_copy -= 1

                    # move right
                    c_copy = 3 - self.column
                    while c_copy > 0:
                        if c_copy == 1:
                            # move right by one tile
                            tiles = deepcopy(tiles_copy)
                            tiles[i][j], tiles[i][j + 1] = tiles[i][j + 1], tiles[i][j]
                            successor_states.append(tiles)
                            move = "L" + str(c_copy) + str(self.column + 1)
                            moves.append(move)
                            # move right by one tile
                        elif c_copy == 2:
                            # move right by two tiles
                            tiles = deepcopy(tiles_copy)
                            tiles[i][j], tiles[i][j + 1] = tiles[i][j + 1], tiles[i][j]
                            tiles[i][j + 1], tiles[i][j + 2] = tiles[i][j + 2], tiles[i][j + 1]
                            successor_states.append(tiles)
                            move = "L" + str(c_copy) + str(self.column + 1)
                            moves.append(move)
                            # move right by two tiles
                        elif c_copy == 3:
                            # move right by three tiles
                            tiles = deepcopy(tiles_copy)
                            tiles[i][j], tiles[i][j + 1] = tiles[i][j + 1], tiles[i][j]
                            tiles[i][j + 1], tiles[i][j + 2] = tiles[i][j + 2], tiles[i][j + 1]
                            tiles[i][j + 2], tiles[i][j + 3] = tiles[i][j + 3], tiles[i][j + 2]
                            successor_states.append(tiles)
                            move = "L" + str(c_copy) + str(self.column + 1)
                            moves.append(move)
                            # move right by three tiles
                        c_copy -= 1

        return [successor_states, moves]

    @staticmethod
    def is_goal(successor_state):
        """
         Checks whether current state is tje goal state or not.
        :param successor_state:
        :return:
        """

        for idx, row in enumerate(successor_state):
            for jdx, value in enumerate(row):
                if value != FINAL_CANONICAL_CONFIGURATION[idx][jdx]:
                    return False

        return True

    @staticmethod
    def get_inv_count(tile):
        """
        http://www.geeksforgeeks.org/check-instance-15-puzzle-solvable/
        A utility function to count inversions in given tile(1-D)
        :param tile:
        :return:
        """

        inv_count = 0
        for i in range(15):
            for j in range(i + 1, 16):
                # count pairs(i, j) such that i appears before j, but i > j.
                if tile[j] and tile[i] and tile[i] > tile[j]:
                    inv_count += 1

        return inv_count

    @staticmethod
    def find_x_position(tile):
        """
        http://www.geeksforgeeks.org/check-instance-15-puzzle-solvable/
        find Position of blank from bottom starting from the bottom-right corner of matrix
        :param tile:
        :return:
        """

        for i in range(3, -1, -1):
            for j in range(3, -1, -1):
                if tile[i][j] == 0:
                    return 4 - i

    @staticmethod
    def is_puzzle_solvable(tile):
        """
        http://www.geeksforgeeks.org/check-instance-15-puzzle-solvable/
        This function returns true if given instance of the 15-puzzle is solvable.
        :param tile:
        :return:
        """

        # Count inversions in given puzzle
        tile_1d = [0 for _ in range(16)]
        for i in range(4):
            for j in range(4):
                tile_1d[4 * i + j] = tile[i][j]

        inv_count = ShortSequenceSolver16.get_inv_count(tile_1d)

        # If grid is odd, return true if inversion count is even.
        if 4 & 1:
            return not inv_count & 1

        pos = ShortSequenceSolver16.find_x_position(tile)
        if pos & 1:
            return not inv_count & 1

        return inv_count & 1

    # Invokes the A-star algorithm to solve the 15-puzzle if it is solvable.
    def solve(self):
        if self.is_solvable:
            return self.solve_a_star(self.initial_state, self.explored_set, self.moves, g_cost=1)

    def solve_a_star(self, state, explored_state, moves, g_cost):
        """
        A-star search finds the best promising state after each
        step based on min 'f'(g + h) value till the goal
        state is reached.
        :param state:
        :param explored_state:
        :param moves:
        :param g_cost:
        :return: Returns a string that represents the output of the program.
        """

        if self.is_goal(state):
            return 0
        # find row and column number of 'blank' tile.
        self.row, self.column = [
            (index, row.index(0)) for index, row in enumerate(state) if 0 in row
        ][0]

        tmp = []
        successors = self.successors(state)[0]
        successors_moves = self.successors(state)[1]

        for cnt, condition in enumerate(successors):
            if self.is_goal(condition):
                explored_state.append(condition)
                moves.append(successors_moves[cnt])
                return 0

            h_cost = ShortSequenceSolver16.manhattan_distance(condition)
            tmp.append((condition, successors_moves[cnt], g_cost + h_cost))

        # https://stackoverflow.com/questions/10695139/sort-a-list-of-tuples-by-2nd-item-integer-value
        # next_promising_state is chosen based on min f_cost = g_cost + h_cost
        next_promising_state = sorted(tmp, key=lambda x: x[2])[0][0]
        explored_state.append(next_promising_state)
        moves.append(sorted(tmp, key=lambda x: x[2])[0][1])
        # https://algorithmsinsight.wordpress.com/graph-theory-2/a-star-in-general/implementing-a-star-to-solve-n-puzzle/
        g_cost += 1

        # recursively iterate through promising states to reach the goal state
        self.solve_a_star(next_promising_state, explored_state, moves, g_cost)

    def __str__(self):
        if self.is_solvable:
            if self.moves:
                output_str = ""
                output_str += "\n".join(
                    str(row) for row in [self.initial_state] + self.explored_set
                )
                output_str += "\n\nSEQUENCE OF MOVES:\n" + " ".join(self.moves)
                return output_str

            return "INPUT PUZZLE IS IN SOLVED STATE."

        return "PUZZLE NOT SOLVABLE"


def main():
    filename = "puzzle.txt"
    solver = ShortSequenceSolver16(filename)
    solver.solve()
    print(str(solver))


if __name__ == "__main__":
    main()
